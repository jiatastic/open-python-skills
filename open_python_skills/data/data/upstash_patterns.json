{
  "source": "https://upstash.com/docs + Context7",
  "version": "2025-01",
  "description": "Upstash Redis, QStash, and Rate Limiting patterns for Python backends",
  "total_entries": 26,
  "entries": [
    {
      "id": "upstash-redis-init",
      "category": "upstash",
      "title": "Redis Client Initialization",
      "tags": ["redis", "upstash", "init", "setup", "connection", "async"],
      "summary": "Initialize Upstash Redis client with explicit credentials or environment variables. Supports both sync and async clients.",
      "content": "Use `Redis.from_env()` to load credentials from UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN environment variables. For async operations, import from `upstash_redis.asyncio`.",
      "code_examples": [
        {
          "description": "Sync client from env",
          "code": "from upstash_redis import Redis\n\nredis = Redis.from_env()"
        },
        {
          "description": "Async client from env",
          "code": "from upstash_redis.asyncio import Redis\n\nredis = Redis.from_env()\n\nasync def main():\n    await redis.set(\"key\", \"value\")\n    value = await redis.get(\"key\")"
        },
        {
          "description": "Explicit credentials",
          "code": "from upstash_redis import Redis\n\nredis = Redis(\n    url=\"UPSTASH_REDIS_REST_URL\",\n    token=\"UPSTASH_REDIS_REST_TOKEN\"\n)"
        }
      ]
    },
    {
      "id": "upstash-redis-ttl",
      "category": "upstash",
      "title": "Key Expiration and TTL",
      "tags": ["redis", "upstash", "ttl", "expire", "expiration", "cache"],
      "summary": "Set key expiration with seconds, milliseconds, or Unix timestamps. Check remaining TTL with ttl() or pttl().",
      "content": "Use `expire()` for seconds, `pexpire()` for milliseconds, `expireat()` for Unix timestamp. Check TTL with `ttl()` (seconds) or `pttl()` (milliseconds). Also supports `timedelta` objects.",
      "code_examples": [
        {
          "description": "Set expiration",
          "code": "import datetime\n\nredis.set(\"session\", \"data\")\nredis.expire(\"session\", 300)  # 5 minutes\nredis.expire(\"token\", datetime.timedelta(hours=1))\nredis.pexpire(\"fast\", 500)  # 500ms"
        },
        {
          "description": "Check TTL",
          "code": "ttl = redis.ttl(\"session\")  # seconds remaining\npttl = redis.pttl(\"session\")  # milliseconds remaining\nexists = redis.exists(\"session\")  # 1 or 0"
        },
        {
          "description": "Set with inline expiration",
          "code": "redis.set(\"key\", \"value\", ex=300)  # expires in 300s\nredis.set(\"key\", \"value\", px=5000)  # expires in 5000ms\nredis.setex(\"key\", 300, \"value\")  # alternative syntax"
        }
      ]
    },
    {
      "id": "upstash-redis-hash",
      "category": "upstash",
      "title": "Redis Hash Operations",
      "tags": ["redis", "upstash", "hash", "hset", "hget", "hgetall"],
      "summary": "Store structured data with hash operations. Useful for user sessions, profiles, and objects.",
      "content": "Use `hset()` with values dict to set multiple fields. Use `hget()` for single field, `hgetall()` for all fields. Combine with `expire()` for session management.",
      "code_examples": [
        {
          "description": "Hash operations",
          "code": "# Set multiple fields\nredis.hset(\"user:1\", values={\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"status\": \"active\"\n})\n\n# Get single field\nname = redis.hget(\"user:1\", \"name\")\n\n# Get all fields\nuser = redis.hgetall(\"user:1\")\n\n# Check field exists\nexists = redis.hexists(\"user:1\", \"email\")"
        }
      ]
    },
    {
      "id": "upstash-redis-transaction",
      "category": "upstash",
      "title": "Redis Transactions (Atomic Operations)",
      "tags": ["redis", "upstash", "transaction", "multi", "exec", "atomic"],
      "summary": "Execute multiple commands atomically using MULTI/EXEC. All commands succeed or none do.",
      "content": "Use `redis.multi()` to start transaction, queue commands, then `exec()` to execute atomically. Useful for transferring balances, updating related keys.",
      "code_examples": [
        {
          "description": "Atomic transaction",
          "code": "tx = redis.multi()\ntx.set(\"account:1\", 1000)\ntx.decrby(\"account:1\", 100)\ntx.set(\"account:2\", 500)\ntx.incrby(\"account:2\", 100)\nresults = tx.exec()  # all or nothing"
        },
        {
          "description": "Chained syntax",
          "code": "results = redis.multi() \\\n    .set(\"balance\", 100) \\\n    .incrby(\"balance\", 50) \\\n    .get(\"balance\") \\\n    .exec()"
        }
      ]
    },
    {
      "id": "upstash-redis-pipeline",
      "category": "upstash",
      "title": "Redis Pipeline (Batch Commands)",
      "tags": ["redis", "upstash", "pipeline", "batch", "performance", "bulk"],
      "summary": "Send multiple commands in a single roundtrip using pipelining. Reduces latency for bulk operations.",
      "content": "Pipeline batches commands without atomicity guarantees (unlike transactions). Commands are queued and executed together via `exec()`. Useful for bulk reads/writes where atomicity is not required.",
      "code_examples": [
        {
          "description": "Basic pipeline",
          "code": "pipeline = redis.pipeline()\n\npipeline.set(\"foo\", 1)\npipeline.incr(\"foo\")\npipeline.get(\"foo\")\n\nresult = pipeline.exec()\nprint(result)  # [True, 2, '2']"
        },
        {
          "description": "Chained pipeline syntax",
          "code": "result = redis.pipeline() \\\n    .set(\"foo\", 1) \\\n    .incr(\"foo\") \\\n    .get(\"foo\") \\\n    .exec()\n\nprint(result)  # [True, 2, '2']"
        },
        {
          "description": "Bulk cache warming",
          "code": "# Warm cache with multiple keys\npipe = redis.pipeline()\nfor user_id in user_ids:\n    pipe.hgetall(f\"user:{user_id}\")\nresults = pipe.exec()  # All results in one roundtrip"
        }
      ]
    },
    {
      "id": "upstash-redis-list",
      "category": "upstash",
      "title": "Redis List Operations",
      "tags": ["redis", "upstash", "list", "lpush", "rpush", "lrange", "queue"],
      "summary": "Use lists for queues, recent items, and ordered collections. Push/pop from head or tail.",
      "content": "Lists support FIFO queues (lpush + rpop) or LIFO stacks (lpush + lpop). Use lrange to get ranges. Good for activity feeds, recent items, job queues.",
      "code_examples": [
        {
          "description": "List operations",
          "code": "# Push to list\nredis.lpush(\"queue\", \"task1\", \"task2\")  # Add to head\nredis.rpush(\"queue\", \"task3\")  # Add to tail\n\n# Get list range\nitems = redis.lrange(\"queue\", 0, -1)  # All items\nrecent = redis.lrange(\"queue\", 0, 9)  # First 10\n\n# Pop items\nfirst = redis.lpop(\"queue\")  # Remove from head\nlast = redis.rpop(\"queue\")  # Remove from tail\n\n# Get length\nlength = redis.llen(\"queue\")"
        },
        {
          "description": "Recent activity feed",
          "code": "# Add activity (keep last 100)\nredis.lpush(\"user:123:activity\", activity_json)\nredis.ltrim(\"user:123:activity\", 0, 99)\n\n# Get recent 10 activities\nrecent = redis.lrange(\"user:123:activity\", 0, 9)"
        }
      ]
    },
    {
      "id": "upstash-redis-set",
      "category": "upstash",
      "title": "Redis Set Operations",
      "tags": ["redis", "upstash", "set", "sadd", "smembers", "sinter", "sunion", "unique"],
      "summary": "Store unique values with sets. Support for union, intersection, and difference operations.",
      "content": "Sets store unique members. Use for tags, unique visitors, permissions. Support set operations: intersection (sinter), union (sunion), difference (sdiff).",
      "code_examples": [
        {
          "description": "Basic set operations",
          "code": "# Add members\nredis.sadd(\"tags:article:1\", \"python\", \"redis\", \"backend\")\n\n# Get all members\ntags = redis.smembers(\"tags:article:1\")  # {'python', 'redis', 'backend'}\n\n# Check membership\nis_member = redis.sismember(\"tags:article:1\", \"python\")  # True\n\n# Remove member\nredis.srem(\"tags:article:1\", \"backend\")\n\n# Get count\ncount = redis.scard(\"tags:article:1\")"
        },
        {
          "description": "Set operations (intersection, union, diff)",
          "code": "redis.sadd(\"user:1:skills\", \"python\", \"redis\", \"fastapi\")\nredis.sadd(\"user:2:skills\", \"python\", \"postgres\", \"fastapi\")\n\n# Intersection - common skills\ncommon = redis.sinter(\"user:1:skills\", \"user:2:skills\")  # {'python', 'fastapi'}\n\n# Union - all skills\nall_skills = redis.sunion(\"user:1:skills\", \"user:2:skills\")\n\n# Difference - unique to user:1\nunique = redis.sdiff(\"user:1:skills\", \"user:2:skills\")  # {'redis'}"
        }
      ]
    },
    {
      "id": "upstash-redis-sorted-set",
      "category": "upstash",
      "title": "Redis Sorted Set Operations",
      "tags": ["redis", "upstash", "sorted-set", "zset", "zadd", "zrange", "leaderboard", "ranking"],
      "summary": "Sorted sets maintain order by score. Perfect for leaderboards, rankings, and time-series data.",
      "content": "Each member has a score for ordering. Use zadd to add with score, zrange/zrevrange to get by rank, zrangebyscore for score ranges. Ideal for leaderboards, priority queues, rate limiting windows.",
      "code_examples": [
        {
          "description": "Leaderboard example",
          "code": "# Add scores\nredis.zadd(\"leaderboard\", {\"alice\": 100, \"bob\": 85, \"charlie\": 92})\n\n# Get top 3 (highest scores first)\ntop3 = redis.zrevrange(\"leaderboard\", 0, 2, withscores=True)\n# [('alice', 100.0), ('charlie', 92.0), ('bob', 85.0)]\n\n# Get rank (0-based, highest first)\nrank = redis.zrevrank(\"leaderboard\", \"bob\")  # 2\n\n# Increment score\nredis.zincrby(\"leaderboard\", 10, \"bob\")  # bob now 95\n\n# Get score\nscore = redis.zscore(\"leaderboard\", \"alice\")  # 100.0"
        },
        {
          "description": "Time-based sorted set",
          "code": "import time\n\n# Store events with timestamp as score\ntimestamp = time.time()\nredis.zadd(\"events\", {event_json: timestamp})\n\n# Get events from last hour\none_hour_ago = time.time() - 3600\nrecent = redis.zrangebyscore(\"events\", one_hour_ago, \"+inf\")\n\n# Remove old events (older than 24h)\nredis.zremrangebyscore(\"events\", \"-inf\", time.time() - 86400)"
        }
      ]
    },
    {
      "id": "upstash-redis-pubsub",
      "category": "upstash",
      "title": "Redis Pub/Sub",
      "tags": ["redis", "upstash", "pubsub", "publish", "subscribe", "messaging", "realtime"],
      "summary": "Publish messages to channels for real-time communication. Note: Upstash REST API has limited pub/sub support.",
      "content": "Use `publish()` to send messages to channels. Returns count of subscribers. Note: Full pub/sub with subscribe requires persistent connections (not available in serverless REST API).",
      "code_examples": [
        {
          "description": "Publish message",
          "code": "# Publish message to channel\nlisteners = redis.publish(\"notifications\", \"New message!\")\nprint(f\"Message sent to {listeners} subscribers\")\n\n# Publish JSON\nimport json\nredis.publish(\"events\", json.dumps({\n    \"type\": \"user_login\",\n    \"user_id\": 123\n}))"
        }
      ]
    },
    {
      "id": "upstash-redis-json",
      "category": "upstash",
      "title": "Redis JSON Operations",
      "tags": ["redis", "upstash", "json", "document", "nested", "path"],
      "summary": "Store and query JSON documents with JSONPath syntax. Update nested fields without fetching entire document.",
      "content": "Use json.set() and json.get() with JSONPath expressions. Supports nested updates, array operations, and partial reads. Requires RedisJSON module (available on Upstash).",
      "code_examples": [
        {
          "description": "JSON operations",
          "code": "# Set JSON document\nredis.json.set(\"user:1\", \"$\", {\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"settings\": {\"theme\": \"dark\", \"notifications\": True}\n})\n\n# Get entire document\nuser = redis.json.get(\"user:1\", \"$\")\n\n# Get nested field\ntheme = redis.json.get(\"user:1\", \"$.settings.theme\")\n\n# Update nested field\nredis.json.set(\"user:1\", \"$.settings.theme\", \"light\")\n\n# Increment numeric field\nredis.json.numincrby(\"user:1\", \"$.login_count\", 1)"
        }
      ]
    },
    {
      "id": "upstash-fastapi-caching",
      "category": "upstash",
      "title": "FastAPI Caching Pattern",
      "tags": ["redis", "upstash", "fastapi", "cache", "caching", "api"],
      "summary": "Cache API responses in Redis. Check cache first, fetch from source if miss, store with TTL.",
      "content": "Pattern: Check cache → Return if hit → Fetch from source → Cache result with TTL → Return. Use consistent key naming like `cache:{resource}:{id}`.",
      "code_examples": [
        {
          "description": "Basic caching pattern",
          "code": "from fastapi import FastAPI\nfrom upstash_redis import Redis\n\napp = FastAPI()\nredis = Redis.from_env()\nCACHE_TTL = 600  # 10 minutes\n\n@app.get(\"/data/{id}\")\ndef get_data(id: str):\n    cache_key = f\"data:{id}\"\n    \n    # Check cache\n    cached = redis.get(cache_key)\n    if cached:\n        return {\"source\": \"cache\", \"data\": cached}\n    \n    # Fetch from source\n    data = fetch_from_database(id)\n    \n    # Cache and return\n    redis.setex(cache_key, CACHE_TTL, data)\n    return {\"source\": \"db\", \"data\": data}"
        }
      ]
    },
    {
      "id": "upstash-fastapi-session",
      "category": "upstash",
      "title": "FastAPI Session Management",
      "tags": ["redis", "upstash", "fastapi", "session", "login", "auth", "cookie"],
      "summary": "Store user sessions in Redis hashes with sliding expiration. Use httponly cookies for session ID.",
      "content": "Generate UUID session ID, store user data in Redis hash, set expiration. Use httponly cookies. Implement sliding expiration by refreshing TTL on each request.",
      "code_examples": [
        {
          "description": "Session management",
          "code": "from fastapi import FastAPI, Response, Cookie, HTTPException\nfrom upstash_redis import Redis\nimport uuid\n\nredis = Redis.from_env()\napp = FastAPI()\nSESSION_TTL = 900  # 15 minutes\n\n@app.post(\"/login\")\nasync def login(username: str, response: Response):\n    session_id = str(uuid.uuid4())\n    redis.hset(f\"session:{session_id}\", values={\n        \"user\": username, \"status\": \"active\"\n    })\n    redis.expire(f\"session:{session_id}\", SESSION_TTL)\n    response.set_cookie(\"session_id\", session_id, httponly=True)\n    return {\"message\": \"Logged in\"}\n\n@app.get(\"/profile\")\nasync def profile(session_id: str = Cookie(None)):\n    if not session_id:\n        raise HTTPException(403, \"No session\")\n    session = redis.hgetall(f\"session:{session_id}\")\n    if not session:\n        raise HTTPException(401, \"Session expired\")\n    redis.expire(f\"session:{session_id}\", SESSION_TTL)  # sliding\n    return session"
        }
      ]
    },
    {
      "id": "upstash-ratelimit-basic",
      "category": "upstash",
      "title": "Rate Limiting - Basic Setup",
      "tags": ["redis", "upstash", "ratelimit", "rate-limit", "throttle", "api"],
      "summary": "Limit API requests using upstash-ratelimit. Supports Fixed Window, Sliding Window, and Token Bucket algorithms.",
      "content": "Install upstash-ratelimit. Choose algorithm based on needs: FixedWindow (simple), SlidingWindow (smoother), TokenBucket (allows bursts). Use IP or user ID as identifier.",
      "code_examples": [
        {
          "description": "Fixed window rate limit",
          "code": "from upstash_ratelimit import Ratelimit, FixedWindow\nfrom upstash_redis import Redis\n\nredis = Redis.from_env()\nratelimit = Ratelimit(\n    redis=redis,\n    limiter=FixedWindow(max_requests=10, window=10),  # 10 req/10s\n    prefix=\"@upstash/ratelimit\"\n)"
        },
        {
          "description": "Sliding window (smoother)",
          "code": "from upstash_ratelimit import Ratelimit, SlidingWindow\n\nratelimit = Ratelimit(\n    redis=Redis.from_env(),\n    limiter=SlidingWindow(max_requests=10, window=10),\n)"
        },
        {
          "description": "Token bucket (allows bursts)",
          "code": "from upstash_ratelimit import Ratelimit, TokenBucket\n\nratelimit = Ratelimit(\n    redis=Redis.from_env(),\n    limiter=TokenBucket(max_tokens=10, refill_rate=5, interval=10),\n)"
        }
      ]
    },
    {
      "id": "upstash-ratelimit-fastapi",
      "category": "upstash",
      "title": "FastAPI Rate Limiting",
      "tags": ["redis", "upstash", "ratelimit", "fastapi", "middleware", "429"],
      "summary": "Apply rate limiting to FastAPI routes. Return 429 when limit exceeded. Can use middleware for global limiting.",
      "content": "Call `ratelimit.limit(identifier)` and check `response.allowed`. Return 429 HTTPException if not allowed. Use request.client.host as identifier for IP-based limiting.",
      "code_examples": [
        {
          "description": "Per-route rate limiting",
          "code": "from fastapi import FastAPI, HTTPException, Request\nfrom upstash_ratelimit import Ratelimit, FixedWindow\nfrom upstash_redis import Redis\n\napp = FastAPI()\nratelimit = Ratelimit(\n    redis=Redis.from_env(),\n    limiter=FixedWindow(max_requests=10, window=10)\n)\n\n@app.get(\"/api/resource\")\ndef protected(request: Request):\n    result = ratelimit.limit(request.client.host)\n    if not result.allowed:\n        raise HTTPException(429, \"Rate limit exceeded\")\n    return {\"data\": \"...\"}"
        },
        {
          "description": "Rate limit middleware",
          "code": "from starlette.middleware.base import BaseHTTPMiddleware\n\nclass RateLimitMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app, ratelimit: Ratelimit):\n        super().__init__(app)\n        self.ratelimit = ratelimit\n    \n    async def dispatch(self, request, call_next):\n        result = self.ratelimit.limit(request.client.host)\n        if not result.allowed:\n            raise HTTPException(429, \"Too many requests\")\n        return await call_next(request)\n\napp.add_middleware(RateLimitMiddleware, ratelimit=ratelimit)"
        }
      ]
    },
    {
      "id": "upstash-ratelimit-multi-tier",
      "category": "upstash",
      "title": "Multi-Tier Rate Limiting",
      "tags": ["redis", "upstash", "ratelimit", "tiers", "pricing", "subscription", "plans"],
      "summary": "Different rate limits for different user tiers (free, paid, enterprise). Use prefixes to separate tracking.",
      "content": "Create multiple Ratelimit instances with different prefixes. Select limiter based on user tier. Good for SaaS products with tiered pricing and API access levels.",
      "code_examples": [
        {
          "description": "Tiered rate limits",
          "code": "from upstash_ratelimit import Ratelimit, SlidingWindow\nfrom upstash_redis import Redis\n\nredis = Redis.from_env()\n\n# Define limits for each tier\nratelimits = {\n    \"free\": Ratelimit(\n        redis=redis,\n        limiter=SlidingWindow(max_requests=10, window=60),  # 10/min\n        prefix=\"ratelimit:free\"\n    ),\n    \"pro\": Ratelimit(\n        redis=redis,\n        limiter=SlidingWindow(max_requests=100, window=60),  # 100/min\n        prefix=\"ratelimit:pro\"\n    ),\n    \"enterprise\": Ratelimit(\n        redis=redis,\n        limiter=SlidingWindow(max_requests=1000, window=60),  # 1000/min\n        prefix=\"ratelimit:enterprise\"\n    )\n}"
        },
        {
          "description": "FastAPI with tiered limits",
          "code": "from fastapi import FastAPI, Depends, HTTPException, Request\n\napp = FastAPI()\n\ndef get_user_tier(request: Request) -> str:\n    # Get tier from auth token, database, etc.\n    return request.state.user.tier  # \"free\", \"pro\", or \"enterprise\"\n\n@app.get(\"/api/data\")\nasync def get_data(request: Request, tier: str = Depends(get_user_tier)):\n    limiter = ratelimits[tier]\n    result = limiter.limit(request.state.user.id)\n    \n    if not result.allowed:\n        raise HTTPException(\n            429,\n            f\"Rate limit exceeded. Upgrade from {tier} for higher limits.\",\n            headers={\"Retry-After\": str(result.reset)}\n        )\n    \n    return {\"data\": \"...\", \"remaining\": result.remaining}"
        }
      ]
    },
    {
      "id": "upstash-ratelimit-response-headers",
      "category": "upstash",
      "title": "Rate Limit Response Headers",
      "tags": ["redis", "upstash", "ratelimit", "headers", "api", "standards"],
      "summary": "Include standard rate limit headers in API responses. Helps clients manage their request rate.",
      "content": "Return X-RateLimit-Limit, X-RateLimit-Remaining, and Retry-After headers. The limit() response includes limit, remaining, and reset values for headers.",
      "code_examples": [
        {
          "description": "Add rate limit headers",
          "code": "from fastapi import FastAPI, Request, Response, HTTPException\nfrom upstash_ratelimit import Ratelimit, SlidingWindow\nfrom upstash_redis import Redis\n\napp = FastAPI()\nratelimit = Ratelimit(\n    redis=Redis.from_env(),\n    limiter=SlidingWindow(max_requests=100, window=60)\n)\n\n@app.middleware(\"http\")\nasync def rate_limit_middleware(request: Request, call_next):\n    identifier = request.client.host\n    result = ratelimit.limit(identifier)\n    \n    if not result.allowed:\n        return Response(\n            content=\"Rate limit exceeded\",\n            status_code=429,\n            headers={\n                \"X-RateLimit-Limit\": str(result.limit),\n                \"X-RateLimit-Remaining\": \"0\",\n                \"Retry-After\": str(result.reset)\n            }\n        )\n    \n    response = await call_next(request)\n    response.headers[\"X-RateLimit-Limit\"] = str(result.limit)\n    response.headers[\"X-RateLimit-Remaining\"] = str(result.remaining)\n    response.headers[\"X-RateLimit-Reset\"] = str(result.reset)\n    return response"
        }
      ]
    },
    {
      "id": "upstash-qstash-setup",
      "category": "upstash",
      "title": "QStash - Client Setup",
      "tags": ["qstash", "upstash", "background", "jobs", "queue", "async"],
      "summary": "QStash is a serverless message queue for background jobs. Initialize client with token.",
      "content": "QStash sends HTTP requests to your endpoints on schedule or after delay. Requires a public endpoint URL. Good for background jobs, scheduled tasks, webhooks.",
      "code_examples": [
        {
          "description": "Initialize QStash client",
          "code": "from qstash import QStash\n\nclient = QStash(\"<QSTASH_TOKEN>\")\n# Or from environment\nclient = QStash.from_env()"
        }
      ]
    },
    {
      "id": "upstash-qstash-publish",
      "category": "upstash",
      "title": "QStash - Publish Messages",
      "tags": ["qstash", "upstash", "publish", "message", "delay", "background"],
      "summary": "Publish messages to endpoints with optional delay, headers, and retry configuration.",
      "content": "Use `client.message.publish_json()` to send JSON payload. Supports delay (e.g., '5m'), custom headers, retries with exponential backoff.",
      "code_examples": [
        {
          "description": "Simple publish",
          "code": "from qstash import QStash\n\nclient = QStash(\"<QSTASH_TOKEN>\")\nres = client.message.publish_json(\n    url=\"https://my-api.com/webhook\",\n    body={\"event\": \"user_signup\", \"user_id\": 123}\n)\nprint(res.message_id)"
        },
        {
          "description": "With delay and headers",
          "code": "res = client.message.publish_json(\n    url=\"https://my-api.com/process\",\n    body={\"task\": \"heavy_computation\"},\n    delay=\"5m\",  # 5 minutes delay\n    headers={\"X-Custom-Header\": \"value\"}\n)"
        },
        {
          "description": "With retry config",
          "code": "res = client.message.publish_json(\n    url=\"https://my-api.com/webhook\",\n    body={\"data\": \"...\"},\n    retries=3,\n    retry_delay=\"pow(2, retried) * 1000\"  # exponential backoff\n)"
        }
      ]
    },
    {
      "id": "upstash-qstash-schedule",
      "category": "upstash",
      "title": "QStash - Schedule Recurring Jobs",
      "tags": ["qstash", "upstash", "schedule", "cron", "recurring", "jobs"],
      "summary": "Schedule recurring jobs using cron syntax. Good for daily reports, hourly syncs, cleanup tasks.",
      "content": "Use `client.schedule.create()` with cron expression. Standard cron format: minute hour day month weekday. Jobs run at specified times.",
      "code_examples": [
        {
          "description": "Schedule recurring jobs",
          "code": "from qstash import QStash\n\nclient = QStash(\"<QSTASH_TOKEN>\")\n\n# Daily at midnight\nclient.schedule.create(\n    destination=\"https://my-api.com/daily-report\",\n    cron=\"0 0 * * *\"\n)\n\n# Every hour\nclient.schedule.create(\n    destination=\"https://my-api.com/sync\",\n    cron=\"0 * * * *\"\n)\n\n# Daily at 3 AM with payload\nclient.schedule.create(\n    destination=\"https://my-api.com/cleanup\",\n    cron=\"0 3 * * *\",\n    body={\"action\": \"cleanup_old_sessions\"}\n)"
        }
      ]
    },
    {
      "id": "upstash-qstash-callback",
      "category": "upstash",
      "title": "QStash - Callbacks and Failure Handling",
      "tags": ["qstash", "upstash", "callback", "failure", "webhook", "error-handling"],
      "summary": "Configure success and failure callbacks to handle message delivery results. Essential for reliable async processing.",
      "content": "Use `callback` for success notifications, `failure_callback` for delivery failures. Callbacks receive the response from your endpoint. Good for logging, alerting, and cleanup.",
      "code_examples": [
        {
          "description": "Success and failure callbacks",
          "code": "from qstash import QStash\n\nclient = QStash(\"<QSTASH_TOKEN>\")\nclient.message.publish_json(\n    url=\"https://my-api.com/process\",\n    body={\"task\": \"heavy_computation\"},\n    callback=\"https://my-api.com/on-success\",\n    failure_callback=\"https://my-api.com/on-failure\"\n)"
        },
        {
          "description": "Callback handler in FastAPI",
          "code": "from fastapi import FastAPI, Request\n\napp = FastAPI()\n\n@app.post(\"/on-success\")\nasync def handle_success(request: Request):\n    data = await request.json()\n    # data contains: {\"status\": 200, \"body\": \"...\"}\n    log_success(data)\n    return {\"received\": True}\n\n@app.post(\"/on-failure\")\nasync def handle_failure(request: Request):\n    data = await request.json()\n    # data contains error details\n    alert_team(data)\n    return {\"received\": True}"
        }
      ]
    },
    {
      "id": "upstash-qstash-verify",
      "category": "upstash",
      "title": "QStash - Signature Verification",
      "tags": ["qstash", "upstash", "security", "signature", "jwt", "verification", "webhook"],
      "summary": "Verify incoming QStash requests to ensure they originate from Upstash. Critical for webhook security.",
      "content": "QStash signs all requests with JWT. Use `Receiver` class to verify signatures. Get signing keys from Upstash Console. Always verify in production to prevent spoofed requests.",
      "code_examples": [
        {
          "description": "Verify with Receiver SDK",
          "code": "from qstash import Receiver\n\nreceiver = Receiver(\n    current_signing_key=\"YOUR_CURRENT_SIGNING_KEY\",\n    next_signing_key=\"YOUR_NEXT_SIGNING_KEY\"\n)\n\n# In your request handler\ndef handle_webhook(request):\n    signature = request.headers[\"Upstash-Signature\"]\n    body = request.body  # Raw body string\n    \n    try:\n        receiver.verify(\n            body=body,\n            signature=signature,\n            url=\"https://my-api.com/webhook\"\n        )\n        # Signature valid, process request\n        return process_message(body)\n    except Exception as e:\n        # Invalid signature\n        return {\"error\": \"Invalid signature\"}, 401"
        },
        {
          "description": "FastAPI webhook with verification",
          "code": "from fastapi import FastAPI, Request, HTTPException\nfrom qstash import Receiver\n\napp = FastAPI()\nreceiver = Receiver(\n    current_signing_key=\"...\",\n    next_signing_key=\"...\"\n)\n\n@app.post(\"/webhook\")\nasync def webhook(request: Request):\n    signature = request.headers.get(\"Upstash-Signature\")\n    body = await request.body()\n    \n    try:\n        receiver.verify(\n            body=body.decode(),\n            signature=signature,\n            url=str(request.url)\n        )\n    except Exception:\n        raise HTTPException(401, \"Invalid signature\")\n    \n    data = await request.json()\n    return await process_task(data)"
        }
      ]
    },
    {
      "id": "upstash-qstash-batch",
      "category": "upstash",
      "title": "QStash - Batch Messages",
      "tags": ["qstash", "upstash", "batch", "bulk", "parallel", "performance"],
      "summary": "Send multiple messages in a single API call. Efficient for bulk operations and fan-out patterns.",
      "content": "Use `batch_json()` to send multiple messages at once. Each message can have different destinations and payloads. Reduces API calls for bulk operations.",
      "code_examples": [
        {
          "description": "Batch publish messages",
          "code": "from qstash import QStash\n\nclient = QStash(\"<QSTASH_TOKEN>\")\n\nresult = client.message.batch_json([\n    {\n        \"url\": \"https://api.com/user/1/notify\",\n        \"body\": {\"message\": \"Hello User 1\"}\n    },\n    {\n        \"url\": \"https://api.com/user/2/notify\",\n        \"body\": {\"message\": \"Hello User 2\"}\n    },\n    {\n        \"url\": \"https://api.com/user/3/notify\",\n        \"body\": {\"message\": \"Hello User 3\"},\n        \"delay\": \"5m\"  # Each message can have different options\n    }\n])\n\nprint(result)  # List of message IDs"
        },
        {
          "description": "Fan-out pattern",
          "code": "# Notify all subscribers\nsubscribers = get_active_subscribers()\n\nmessages = [\n    {\n        \"url\": f\"https://api.com/notify/{sub.id}\",\n        \"body\": {\"event\": event_data},\n        \"callback\": \"https://api.com/delivery-status\"\n    }\n    for sub in subscribers\n]\n\nclient.message.batch_json(messages)"
        }
      ]
    },
    {
      "id": "upstash-qstash-queue",
      "category": "upstash",
      "title": "QStash - Queue Management",
      "tags": ["qstash", "upstash", "queue", "enqueue", "parallelism", "concurrency"],
      "summary": "Use queues for controlled concurrency. Messages are processed in order with configurable parallelism.",
      "content": "Create named queues with `client.queue()`. Use `enqueue_json()` to add messages. Queues provide FIFO ordering and rate-controlled processing. Good for job queues with limited workers.",
      "code_examples": [
        {
          "description": "Enqueue to named queue",
          "code": "from qstash import QStash\n\nclient = QStash(\"<QSTASH_TOKEN>\")\n\n# Enqueue message to a queue\nresult = client.message.enqueue_json(\n    queue=\"email-queue\",\n    url=\"https://my-api.com/send-email\",\n    body={\n        \"to\": \"user@example.com\",\n        \"subject\": \"Welcome!\",\n        \"template\": \"welcome\"\n    }\n)\n\nprint(result.message_id)"
        },
        {
          "description": "Queue with LLM integration",
          "code": "from qstash import QStash\nfrom qstash.chat import openai\n\nclient = QStash(\"<QSTASH_TOKEN>\")\n\n# Queue LLM requests for rate-limited processing\nresult = client.message.enqueue_json(\n    queue=\"llm-queue\",\n    api={\"name\": \"llm\", \"provider\": openai(\"<OPENAI_API_KEY>\")},\n    body={\n        \"model\": \"gpt-4\",\n        \"messages\": [\n            {\"role\": \"user\", \"content\": \"Summarize this article...\"}\n        ]\n    },\n    callback=\"https://my-api.com/llm-result\"\n)"
        }
      ]
    },
    {
      "id": "upstash-fastapi-dependency",
      "category": "upstash",
      "title": "FastAPI Redis Dependency Injection",
      "tags": ["redis", "upstash", "fastapi", "dependency", "depends", "injection"],
      "summary": "Inject Redis client into FastAPI routes using Depends(). Clean separation of concerns.",
      "content": "Create a dependency function that returns Redis client. Use `Depends()` in route parameters. Enables testing with mock Redis.",
      "code_examples": [
        {
          "description": "Redis dependency",
          "code": "from fastapi import FastAPI, Depends\nfrom upstash_redis import Redis\n\napp = FastAPI()\n\ndef get_redis() -> Redis:\n    return Redis.from_env()\n\n@app.get(\"/data/{key}\")\nasync def get_data(key: str, redis: Redis = Depends(get_redis)):\n    value = redis.get(key)\n    return {\"key\": key, \"value\": value}\n\n@app.post(\"/data/{key}\")\nasync def set_data(key: str, value: str, redis: Redis = Depends(get_redis)):\n    redis.set(key, value)\n    return {\"status\": \"ok\"}"
        }
      ]
    },
    {
      "id": "upstash-error-handling",
      "category": "upstash",
      "title": "Error Handling and Retry",
      "tags": ["redis", "upstash", "error", "retry", "exception", "handling"],
      "summary": "Built-in retry mechanism handles transient errors. Customize retries and interval. Catch UpstashError for custom handling.",
      "content": "Default: 1 retry after 3 seconds. Customize with `rest_retries` and `rest_retry_interval`. Import `UpstashError` for exception handling.",
      "code_examples": [
        {
          "description": "Custom retry config",
          "code": "from upstash_redis import Redis\n\nredis = Redis(\n    url=\"...\",\n    token=\"...\",\n    rest_retries=3,\n    rest_retry_interval=1  # seconds\n)"
        },
        {
          "description": "Error handling",
          "code": "from upstash_redis import Redis\nfrom upstash_redis.errors import UpstashError\n\nredis = Redis.from_env()\n\ntry:\n    value = redis.get(\"key\")\nexcept UpstashError as e:\n    print(f\"Redis error: {e}\")\n    # Fallback logic"
        }
      ]
    },
    {
      "id": "upstash-best-practices",
      "category": "upstash",
      "title": "Upstash Best Practices",
      "tags": ["redis", "upstash", "best-practices", "tips", "patterns"],
      "summary": "Key patterns: use env vars, set TTLs, use key prefixes, choose right rate limit algorithm, use async for async routes.",
      "content": "1. Use environment variables for credentials\n2. Always set TTLs to avoid memory bloat\n3. Use key prefixes: user:123, session:abc, cache:weather:london\n4. Choose rate limit algorithm based on needs\n5. Use async client for async routes\n6. Verify QStash signatures for webhook security\n7. Use transactions for atomic operations",
      "code_examples": [
        {
          "description": "Key naming conventions",
          "code": "# Good key naming\nredis.set(\"user:123:profile\", data)\nredis.set(\"session:abc123\", session_data)\nredis.set(\"cache:weather:london\", weather_data)\nredis.set(\"ratelimit:api:192.168.1.1\", count)"
        }
      ]
    }
  ]
}
