{
  "source": "Curated code quality patterns",
  "version": "2026-01-04",
  "description": "Deslopification patterns for AI-generated code",
  "entries": [
    {
      "id": "deslop-remove-emojis",
      "category": "deslop",
      "title": "Remove Emojis from Code",
      "tags": [
        "deslop",
        "cleanup",
        "emoji",
        "code-quality"
      ],
      "summary": "Remove emojis from code/comments/strings for production readability and compatibility.",
      "content": "Emojis reduce readability and can cause terminal/parser issues. Remove them from production code and user-visible error messages unless explicitly desired.",
      "code_examples": [
        {
          "description": "Remove emojis with regex",
          "code": "import re\n\nEMOJI_RE = re.compile(\n    \"[\"  # basic unicode emoji ranges\n    \"\\U0001F300-\\U0001F5FF\"\n    \"\\U0001F600-\\U0001F64F\"\n    \"\\U0001F680-\\U0001F6FF\"\n    \"\\U0001F1E0-\\U0001F1FF\"\n    \"]+\",\n    flags=re.UNICODE,\n)\n\ndef remove_emoji(text: str) -> str:\n    return EMOJI_RE.sub(\"\", text)\n"
        }
      ]
    },
    {
      "id": "deslop-remove-redundant-comments",
      "category": "deslop",
      "title": "Remove Redundant or Unnatural Comments",
      "tags": [
        "deslop",
        "cleanup",
        "comments",
        "readability",
        "code-quality"
      ],
      "summary": "Delete comments that restate the code or add AI-like narration; keep only intent, constraints, and non-obvious reasoning.",
      "content": "AI-generated code often includes step-by-step narration (\"Now we do X\") or comments that just repeat what the code already says. Remove those. Keep comments that capture intent, invariants, constraints, tricky edge cases, or why a decision was made. Match the surrounding file's comment density and tone.",
      "code_examples": [
        {
          "description": "Prefer intent comments over narration",
          "code": "# Bad: narration / restating\n# Now we open the file and read its contents\ntext = path.read_text(encoding=\"utf-8\")\n\n# Good: captures intent/constraint\n# We read as UTF-8 because the knowledge DB is stored as UTF-8 JSON.\ntext = path.read_text(encoding=\"utf-8\")\n"
        }
      ]
    },
    {
      "id": "deslop-remove-overdefensive-validation",
      "category": "deslop",
      "title": "Remove Over-Defensive Checks on Trusted Code Paths",
      "tags": [
        "deslop",
        "cleanup",
        "defensive",
        "validation",
        "code-quality"
      ],
      "summary": "Avoid repeated validations in inner layers when inputs are already validated by earlier, trusted boundaries.",
      "content": "AI code frequently adds redundant checks (None checks, type checks, empty checks) in many layers. Prefer a single validation boundary (e.g., API layer, CLI args parsing, Pydantic models) and keep inner functions focused. Keep only the validations that guard truly untrusted input or protect against common programmer mistakes at module boundaries.",
      "code_examples": [
        {
          "description": "Validate once at the boundary, keep core logic clean",
          "code": "def parse_limit(limit_str: str) -> int:\n    # Boundary validation (trusted downstream)\n    limit = int(limit_str)\n    if limit <= 0:\n        raise ValueError(\"limit must be positive\")\n    return limit\n\ndef top_n(items: list[str], limit: int) -> list[str]:\n    # No repeated validation here if limit is already validated by parse_limit().\n    return items[:limit]\n"
        }
      ]
    },
    {
      "id": "deslop-remove-unnecessary-try-except",
      "category": "deslop",
      "title": "Remove Unnecessary try/except Wrappers",
      "tags": [
        "deslop",
        "cleanup",
        "exceptions",
        "error-handling",
        "code-quality"
      ],
      "summary": "Don't wrap everything in broad try/except; catch only what you can handle and let unexpected errors surface.",
      "content": "AI code often wraps large blocks in broad exception handlers (\"except Exception\") and then rethrows or prints generic errors. Prefer catching specific exceptions when you can recover, add context, or convert to a domain-specific error. Otherwise let exceptions propagate so failures are visible and debuggable. If you must add context, use exception chaining (raise ... from e).",
      "code_examples": [
        {
          "description": "Catch specific errors or add context with chaining",
          "code": "# Bad: broad wrapper that hides stack traces\ntry:\n    data = json.loads(text)\nexcept Exception:\n    return {}\n\n# Good: specific exception + explicit failure\ntry:\n    data = json.loads(text)\nexcept json.JSONDecodeError as e:\n    raise ValueError(\"Invalid JSON in config\") from e\n"
        }
      ]
    },
    {
      "id": "deslop-avoid-type-escapes",
      "category": "deslop",
      "title": "Avoid Type Escapes (Any, casts) as a Band-Aid",
      "tags": [
        "deslop",
        "cleanup",
        "typing",
        "any",
        "code-quality"
      ],
      "summary": "Don't use Any/casts to silence type issues; model the real types or refactor to keep typing accurate.",
      "content": "AI-generated code may introduce Any, casts, or vague dict usage to make type checkers \"happy\". Prefer modeling the correct types (TypedDict, dataclasses, Pydantic models) or narrowing types via checks when needed. Use casts sparingly and only when you can justify correctness. Keep typing style consistent with the codebase.",
      "code_examples": [
        {
          "description": "Prefer explicit models over Any",
          "code": "from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass User:\n    id: str\n    email: str\n\n# Prefer returning User instead of dict[str, Any].\ndef parse_user(payload: dict) -> User:\n    return User(id=str(payload[\"id\"]), email=str(payload[\"email\"]))\n"
        }
      ]
    },
    {
      "id": "deslop-match-local-style",
      "category": "deslop",
      "title": "Match Local Style and Patterns",
      "tags": [
        "deslop",
        "cleanup",
        "style",
        "refactor",
        "code-quality"
      ],
      "summary": "Prefer the repoâ€™s existing patterns (naming, structure, formatting, libraries) over generic AI defaults.",
      "content": "Deslop is not only about removing code; it's also about consistency. When editing a file, match its existing style: naming conventions, logging approach, error messaging, helper function patterns, and dependency choices. Avoid introducing new abstractions unless they pay for themselves in reuse or clarity.",
      "code_examples": [
        {
          "description": "Keep changes minimal and consistent",
          "code": "# Guideline: if the file uses Path objects, keep Path objects.\n# Guideline: if the file prints plain text errors, do not switch to a new logging framework.\n"
        }
      ]
    }
  ]
}
