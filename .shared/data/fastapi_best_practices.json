{
  "source": "https://github.com/zhanymkanov/fastapi-best-practices",
  "version": "2024-01",
  "description": "Complete FastAPI best practices from zhanymkanov/fastapi-best-practices repository",
  "entries": [
    {
      "id": "project-structure",
      "category": "architecture",
      "title": "Project Structure - Domain-Driven",
      "tags": [
        "structure",
        "organization",
        "modules",
        "netflix",
        "dispatch",
        "monolith"
      ],
      "summary": "Domain-driven project structure inspired by Netflix's Dispatch. Store all domain directories inside src folder, each package has its own router, schemas, models, service, dependencies.",
      "content": "There are many ways to structure a project, but the best structure is one that is consistent, straightforward, and free of surprises.\n\nMany example projects divide by file type (crud, routers, models), which works well for microservices. However, for monoliths with many domains, domain-driven structure is more scalable.\n\nStore all domain directories inside `src` folder. Each package has:\n- router.py - core endpoints\n- schemas.py - pydantic models\n- models.py - db models\n- service.py - business logic\n- dependencies.py - router dependencies\n- constants.py - module constants and error codes\n- config.py - env vars\n- utils.py - non-business logic functions\n- exceptions.py - module specific exceptions\n\nImport from other packages with explicit module names:\n```python\nfrom src.auth import constants as auth_constants\nfrom src.notifications import service as notification_service\nfrom src.posts.constants import ErrorCode as PostsErrorCode\n```",
      "code_examples": [
        {
          "description": "Project structure example",
          "code": "fastapi-project\n├── alembic/\n├── src\n│   ├── auth\n│   │   ├── router.py\n│   │   ├── schemas.py  # pydantic models\n│   │   ├── models.py  # db models\n│   │   ├── dependencies.py\n│   │   ├── config.py\n│   │   ├── constants.py\n│   │   ├── exceptions.py\n│   │   ├── service.py\n│   │   └── utils.py\n│   ├── posts\n│   │   ├── router.py\n│   │   ├── schemas.py\n│   │   ├── models.py\n│   │   └── ...\n│   ├── config.py  # global configs\n│   ├── models.py  # global models\n│   ├── exceptions.py\n│   ├── pagination.py\n│   ├── database.py\n│   └── main.py\n├── tests/\n├── templates/\n└── requirements/"
        },
        {
          "description": "Explicit module imports",
          "code": "from src.auth import constants as auth_constants\nfrom src.notifications import service as notification_service\nfrom src.posts.constants import ErrorCode as PostsErrorCode"
        }
      ]
    },
    {
      "id": "async-routes-io",
      "category": "async",
      "title": "Async Routes - I/O Intensive Tasks",
      "tags": [
        "async",
        "sync",
        "blocking",
        "event-loop",
        "threadpool",
        "io"
      ],
      "summary": "FastAPI handles sync routes in threadpool, async routes on event loop. Never use blocking operations in async routes - use sync def or await async operations.",
      "content": "FastAPI is an async framework. Under the hood:\n- FastAPI runs `sync` routes in the threadpool - blocking I/O won't stop the event loop\n- If route is `async`, it's called via `await` - FastAPI trusts you to do only non-blocking I/O\n\nThe caveat: if you violate that trust and execute blocking operations within async routes, the event loop will not be able to run subsequent tasks until the blocking operation completes.",
      "code_examples": [
        {
          "description": "BAD - blocks event loop",
          "code": "@router.get(\"/terrible-ping\")\nasync def terrible_ping():\n    time.sleep(10)  # I/O blocking operation, whole process blocked\n    return {\"pong\": True}"
        },
        {
          "description": "GOOD - runs in threadpool",
          "code": "@router.get(\"/good-ping\")\ndef good_ping():\n    time.sleep(10)  # Blocking but in separate thread\n    return {\"pong\": True}"
        },
        {
          "description": "PERFECT - non-blocking async",
          "code": "@router.get(\"/perfect-ping\")\nasync def perfect_ping():\n    await asyncio.sleep(10)  # Non-blocking I/O\n    return {\"pong\": True}"
        }
      ]
    },
    {
      "id": "async-routes-cpu",
      "category": "async",
      "title": "Async Routes - CPU Intensive Tasks",
      "tags": [
        "async",
        "cpu",
        "gil",
        "threadpool",
        "workers"
      ],
      "summary": "CPU-intensive tasks should not be awaited or run in threadpool due to GIL. Send them to workers in another process.",
      "content": "Operations that are non-blocking awaitables or sent to thread pool must be I/O intensive tasks (e.g. open file, db call, external API call).\n\n- Awaiting CPU-intensive tasks is worthless - CPU has to work to finish\n- Running CPU-intensive tasks in threads isn't effective due to GIL (Global Interpreter Lock)\n- If you want to optimize CPU intensive tasks, send them to workers in another process",
      "code_examples": []
    },
    {
      "id": "pydantic-excessive",
      "category": "pydantic",
      "title": "Excessively Use Pydantic",
      "tags": [
        "pydantic",
        "validation",
        "schemas",
        "enums",
        "email"
      ],
      "summary": "Pydantic has rich features for validation and transformation. Use Field constraints, enums, EmailStr, AnyUrl, regex patterns.",
      "content": "Pydantic has built-in comprehensive data processing tools:\n- Required & non-required fields with defaults\n- Regex patterns\n- Enums\n- String manipulation\n- Email validation\n- URL validation",
      "code_examples": [
        {
          "description": "Rich Pydantic validation",
          "code": "from enum import Enum\nfrom pydantic import AnyUrl, BaseModel, EmailStr, Field\n\nclass MusicBand(str, Enum):\n   AEROSMITH = \"AEROSMITH\"\n   QUEEN = \"QUEEN\"\n   ACDC = \"AC/DC\"\n\nclass UserBase(BaseModel):\n    first_name: str = Field(min_length=1, max_length=128)\n    username: str = Field(min_length=1, max_length=128, pattern=\"^[A-Za-z0-9-_]+$\")\n    email: EmailStr\n    age: int = Field(ge=18, default=None)\n    favorite_band: MusicBand | None = None\n    website: AnyUrl | None = None"
        }
      ]
    },
    {
      "id": "pydantic-custom-base",
      "category": "pydantic",
      "title": "Custom Base Model",
      "tags": [
        "pydantic",
        "base-model",
        "serialization",
        "datetime"
      ],
      "summary": "Create a controllable global base model to customize all models - enforce standard datetime format, common methods.",
      "content": "Having a controllable global base model allows us to customize all models within the app. For instance:\n- Enforce standard datetime format\n- Introduce common methods for all subclasses",
      "code_examples": [
        {
          "description": "Custom base model with datetime serialization",
          "code": "from datetime import datetime\nfrom zoneinfo import ZoneInfo\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseModel, ConfigDict\n\ndef datetime_to_gmt_str(dt: datetime) -> str:\n    if not dt.tzinfo:\n        dt = dt.replace(tzinfo=ZoneInfo(\"UTC\"))\n    return dt.strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n\nclass CustomModel(BaseModel):\n    model_config = ConfigDict(\n        json_encoders={datetime: datetime_to_gmt_str},\n        populate_by_name=True,\n    )\n\n    def serializable_dict(self, **kwargs):\n        \"\"\"Return a dict which contains only serializable fields.\"\"\"\n        default_dict = self.model_dump()\n        return jsonable_encoder(default_dict)"
        }
      ]
    },
    {
      "id": "pydantic-basesettings",
      "category": "pydantic",
      "title": "Decouple Pydantic BaseSettings",
      "tags": [
        "pydantic",
        "config",
        "settings",
        "environment"
      ],
      "summary": "Split BaseSettings across different modules and domains instead of a single BaseSettings for the whole app.",
      "content": "BaseSettings was great for reading environment variables, but having a single BaseSettings for the whole app can become messy. Split BaseSettings across different modules and domains.",
      "code_examples": [
        {
          "description": "Domain-specific configs",
          "code": "# src.auth.config\nfrom pydantic_settings import BaseSettings\n\nclass AuthConfig(BaseSettings):\n    JWT_ALG: str\n    JWT_SECRET: str\n    JWT_EXP: int = 5  # minutes\n    REFRESH_TOKEN_KEY: str\n    SECURE_COOKIES: bool = True\n\nauth_settings = AuthConfig()\n\n# src.config\nfrom pydantic import PostgresDsn, RedisDsn\nfrom pydantic_settings import BaseSettings\n\nclass Config(BaseSettings):\n    DATABASE_URL: PostgresDsn\n    REDIS_URL: RedisDsn\n    SITE_DOMAIN: str = \"myapp.com\"\n    ENVIRONMENT: Environment = Environment.PRODUCTION\n\nsettings = Config()"
        }
      ]
    },
    {
      "id": "dependencies-validation",
      "category": "dependencies",
      "title": "Beyond Dependency Injection - Request Validation",
      "tags": [
        "dependencies",
        "validation",
        "database",
        "reuse"
      ],
      "summary": "Dependencies are excellent for request validation. Use them to validate data against database constraints (e.g., checking if email exists, ensuring user is found).",
      "content": "Pydantic is great for schema validation, but for complex validations involving database or external services, dependencies are better.\n\nDependencies can validate data against database constraints:\n- Checking if email already exists\n- Ensuring a user is found\n- Validating ownership",
      "code_examples": [
        {
          "description": "Validation dependency",
          "code": "# dependencies.py\nasync def valid_post_id(post_id: UUID4) -> dict[str, Any]:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n    return post\n\n# router.py\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post_by_id(post: dict[str, Any] = Depends(valid_post_id)):\n    return post\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    update_data: PostUpdate,\n    post: dict[str, Any] = Depends(valid_post_id),\n):\n    updated_post = await service.update(id=post[\"id\"], data=update_data)\n    return updated_post"
        }
      ]
    },
    {
      "id": "dependencies-chain",
      "category": "dependencies",
      "title": "Chain Dependencies",
      "tags": [
        "dependencies",
        "chain",
        "reuse",
        "jwt",
        "auth"
      ],
      "summary": "Dependencies can use other dependencies to avoid code repetition for similar logic.",
      "content": "Dependencies can use other dependencies and avoid code repetition for similar logic.",
      "code_examples": [
        {
          "description": "Chained dependencies",
          "code": "# dependencies.py\nasync def valid_post_id(post_id: UUID4) -> dict[str, Any]:\n    post = await service.get_by_id(post_id)\n    if not post:\n        raise PostNotFound()\n    return post\n\nasync def parse_jwt_data(\n    token: str = Depends(OAuth2PasswordBearer(tokenUrl=\"/auth/token\"))\n) -> dict[str, Any]:\n    try:\n        payload = jwt.decode(token, \"JWT_SECRET\", algorithms=[\"HS256\"])\n    except JWTError:\n        raise InvalidCredentials()\n    return {\"user_id\": payload[\"id\"]}\n\nasync def valid_owned_post(\n    post: dict[str, Any] = Depends(valid_post_id),\n    token_data: dict[str, Any] = Depends(parse_jwt_data),\n) -> dict[str, Any]:\n    if post[\"creator_id\"] != token_data[\"user_id\"]:\n        raise UserNotOwner()\n    return post"
        }
      ]
    },
    {
      "id": "dependencies-cache",
      "category": "dependencies",
      "title": "Decouple & Reuse Dependencies - Caching",
      "tags": [
        "dependencies",
        "cache",
        "reuse",
        "performance"
      ],
      "summary": "Dependencies can be reused multiple times, and they won't be recalculated - FastAPI caches dependency's result within a request's scope by default.",
      "content": "FastAPI caches dependency's result within a request's scope by default. If a dependency gets called multiple times in one route, it will be called only once.\n\nWe can decouple dependencies onto multiple smaller functions that operate on a smaller domain and are easier to reuse.",
      "code_examples": [
        {
          "description": "Reused cached dependency",
          "code": "# parse_jwt_data is used 3 times but called only once\n@router.get(\"/users/{user_id}/posts/{post_id}\", response_model=PostResponse)\nasync def get_user_post(\n    worker: BackgroundTasks,\n    post: Mapping = Depends(valid_owned_post),  # uses parse_jwt_data\n    user: Mapping = Depends(valid_active_creator),  # uses parse_jwt_data\n):\n    # parse_jwt_data is called only once, cached for this request\n    worker.add_task(notifications_service.send_email, user[\"id\"])\n    return post"
        }
      ]
    },
    {
      "id": "dependencies-async",
      "category": "dependencies",
      "title": "Prefer Async Dependencies",
      "tags": [
        "dependencies",
        "async",
        "threadpool",
        "performance"
      ],
      "summary": "FastAPI supports both sync and async dependencies. Prefer async dependencies - sync dependencies run in thread pool with limitations.",
      "content": "Just as with routes, sync dependencies are run in the thread pool. Threads come with a price and limitations that are redundant if you just make a small non-I/O operation.",
      "code_examples": []
    },
    {
      "id": "rest-conventions",
      "category": "api",
      "title": "Follow the REST",
      "tags": [
        "rest",
        "api",
        "routing",
        "dependencies"
      ],
      "summary": "Developing RESTful API makes it easier to reuse dependencies. Use consistent variable names in paths.",
      "content": "RESTful API makes it easier to reuse dependencies in routes. The caveat is having to use the same variable names in the path.\n\nIf you have two endpoints that validate the same thing, rename path variables to match and chain dependencies.",
      "code_examples": [
        {
          "description": "RESTful path variables",
          "code": "# Use profile_id consistently\n@router.get(\"/profiles/{profile_id}\", response_model=ProfileResponse)\nasync def get_user_profile_by_id(profile: Mapping = Depends(valid_profile_id)):\n    return profile\n\n# Chain dependencies by using same variable name\n@router.get(\"/creators/{profile_id}\", response_model=ProfileResponse)\nasync def get_user_profile_by_id(\n     creator_profile: Mapping = Depends(valid_creator_id)  # uses valid_profile_id\n):\n    return creator_profile"
        }
      ]
    },
    {
      "id": "response-serialization",
      "category": "performance",
      "title": "FastAPI Response Serialization",
      "tags": [
        "response",
        "serialization",
        "pydantic",
        "performance"
      ],
      "summary": "FastAPI first converts Pydantic object to dict with jsonable_encoder, then validates with response_model, then serializes. Your model is created twice.",
      "content": "FastAPI first converts that pydantic object to dict with its jsonable_encoder, then validates data with your response_model, and only then serializes your object to JSON.\n\nThis means your Pydantic model object is created twice:\n- First, when you explicitly create it to return from your route\n- Second, implicitly by FastAPI to validate the response data",
      "code_examples": []
    },
    {
      "id": "sync-sdk-threadpool",
      "category": "async",
      "title": "Sync SDK in Thread Pool",
      "tags": [
        "async",
        "sync",
        "threadpool",
        "external-api"
      ],
      "summary": "If you must use a library that's not async, make HTTP calls in an external worker thread using run_in_threadpool.",
      "content": "If you must use a library to interact with external services, and it's not async, then make the HTTP calls in an external worker thread.\n\nUse run_in_threadpool from starlette.",
      "code_examples": [
        {
          "description": "Run sync SDK in threadpool",
          "code": "from fastapi.concurrency import run_in_threadpool\nfrom my_sync_library import SyncAPIClient\n\n@app.get(\"/\")\nasync def call_my_sync_library():\n    my_data = await service.get_my_data()\n    client = SyncAPIClient()\n    await run_in_threadpool(client.make_request, data=my_data)"
        }
      ]
    },
    {
      "id": "pydantic-valueerror",
      "category": "pydantic",
      "title": "ValueErrors Become Pydantic ValidationError",
      "tags": [
        "pydantic",
        "validation",
        "errors",
        "user-friendly"
      ],
      "summary": "If you raise a ValueError in a Pydantic schema that is directly faced by the client, it will return a nice detailed response to users.",
      "content": "If you raise a ValueError in a Pydantic schema that is directly faced by the client, it will return a nice detailed response to users.",
      "code_examples": [
        {
          "description": "ValueError in validator",
          "code": "from pydantic import BaseModel, field_validator\n\nclass ProfileCreate(BaseModel):\n    username: str\n    password: str\n\n    @field_validator(\"password\", mode=\"after\")\n    @classmethod\n    def valid_password(cls, password: str) -> str:\n        if not re.match(STRONG_PASSWORD_PATTERN, password):\n            raise ValueError(\n                \"Password must contain at least \"\n                \"one lower character, \"\n                \"one upper character, \"\n                \"digit or \"\n                \"special symbol\"\n            )\n        return password"
        }
      ]
    },
    {
      "id": "docs-hide-default",
      "category": "api",
      "title": "Hide Docs by Default",
      "tags": [
        "docs",
        "openapi",
        "security",
        "environment"
      ],
      "summary": "Unless your API is public, hide docs by default. Show it explicitly on selected envs only.",
      "content": "Unless your API is public, hide docs by default. Show it explicitly on selected envs only.",
      "code_examples": [
        {
          "description": "Conditional docs",
          "code": "from fastapi import FastAPI\nfrom starlette.config import Config\n\nconfig = Config(\".env\")\nENVIRONMENT = config(\"ENVIRONMENT\")\nSHOW_DOCS_ENVIRONMENT = (\"local\", \"staging\")\n\napp_configs = {\"title\": \"My Cool API\"}\nif ENVIRONMENT not in SHOW_DOCS_ENVIRONMENT:\n   app_configs[\"openapi_url\"] = None\n\napp = FastAPI(**app_configs)"
        }
      ]
    },
    {
      "id": "docs-detailed",
      "category": "api",
      "title": "Detailed API Documentation",
      "tags": [
        "docs",
        "openapi",
        "response-model",
        "status-code"
      ],
      "summary": "Set response_model, status_code, description, etc. Use responses route attribute for different response models.",
      "content": "Help FastAPI generate easy-to-understand docs:\n- Set response_model, status_code, description\n- If models and statuses vary, use responses route attribute",
      "code_examples": [
        {
          "description": "Detailed route documentation",
          "code": "from fastapi import APIRouter, status\n\n@router.post(\n    \"/endpoints\",\n    response_model=DefaultResponseModel,\n    status_code=status.HTTP_201_CREATED,\n    description=\"Description of the well documented endpoint\",\n    tags=[\"Endpoint Category\"],\n    summary=\"Summary of the Endpoint\",\n    responses={\n        status.HTTP_200_OK: {\n            \"model\": OkResponse,\n            \"description\": \"Ok Response\",\n        },\n        status.HTTP_201_CREATED: {\n            \"model\": CreatedResponse,\n            \"description\": \"Creates something from user request\",\n        },\n    },\n)\nasync def documented_route():\n    pass"
        }
      ]
    },
    {
      "id": "db-naming-conventions",
      "category": "database",
      "title": "Set DB Naming Conventions",
      "tags": [
        "database",
        "naming",
        "conventions",
        "sqlalchemy"
      ],
      "summary": "Be consistent with names: lower_case_snake, singular form, group similar tables with module prefix, _at suffix for datetime, _date for date.",
      "content": "Being consistent with names is important:\n1. lower_case_snake\n2. singular form (e.g. post, post_like, user_playlist)\n3. group similar tables with module prefix (e.g. payment_account, payment_bill)\n4. stay consistent across tables (use profile_id in all tables)\n5. _at suffix for datetime\n6. _date suffix for date",
      "code_examples": []
    },
    {
      "id": "db-index-naming",
      "category": "database",
      "title": "Set DB Keys Naming Conventions",
      "tags": [
        "database",
        "indexes",
        "naming",
        "postgres"
      ],
      "summary": "Explicitly setting indexes' namings according to your database's convention is preferable over sqlalchemy's.",
      "content": "Explicitly setting indexes' namings according to your database's convention is preferable over sqlalchemy's.",
      "code_examples": [
        {
          "description": "PostgreSQL naming convention",
          "code": "from sqlalchemy import MetaData\n\nPOSTGRES_INDEXES_NAMING_CONVENTION = {\n    \"ix\": \"%(column_0_label)s_idx\",\n    \"uq\": \"%(table_name)s_%(column_0_name)s_key\",\n    \"ck\": \"%(table_name)s_%(constraint_name)s_check\",\n    \"fk\": \"%(table_name)s_%(column_0_name)s_fkey\",\n    \"pk\": \"%(table_name)s_pkey\",\n}\nmetadata = MetaData(naming_convention=POSTGRES_INDEXES_NAMING_CONVENTION)"
        }
      ]
    },
    {
      "id": "migrations-alembic",
      "category": "database",
      "title": "Migrations - Alembic",
      "tags": [
        "database",
        "migrations",
        "alembic",
        "versioning"
      ],
      "summary": "Migrations must be static and revertable. Generate migrations with descriptive names & slugs. Set human-readable file template.",
      "content": "1. Migrations must be static and revertable\n2. Generate migrations with descriptive names & slugs\n3. Set human-readable file template for new migrations (e.g. date_slug.py)",
      "code_examples": [
        {
          "description": "Alembic file template",
          "code": "# alembic.ini\nfile_template = %%(year)d-%%(month).2d-%%(day).2d_%%(slug)s\n# Results in: 2022-08-24_post_content_idx.py"
        }
      ]
    },
    {
      "id": "sql-first-pydantic-second",
      "category": "database",
      "title": "SQL-first. Pydantic-second",
      "tags": [
        "database",
        "sql",
        "pydantic",
        "performance",
        "joins"
      ],
      "summary": "Database handles data processing much faster than CPython. Do complex joins and simple data manipulations with SQL. Aggregate JSONs in DB for nested objects.",
      "content": "Usually, database handles data processing much faster and cleaner than CPython will ever do.\n- It's preferable to do all complex joins and simple data manipulations with SQL\n- It's preferable to aggregate JSONs in DB for responses with nested objects",
      "code_examples": [
        {
          "description": "SQL aggregation example",
          "code": "from sqlalchemy import func, select, text\n\nselect_query = (\n    select(\n        posts.c.id,\n        posts.c.title,\n        func.json_build_object(\n           text(\"'id', profiles.id\"),\n           text(\"'first_name', profiles.first_name\"),\n           text(\"'username', profiles.username\"),\n        ).label(\"creator\"),\n    )\n    .select_from(posts.join(profiles, posts.c.owner_id == profiles.c.id))\n    .where(posts.c.owner_id == creator_id)\n)\n\nreturn await database.fetch_all(select_query)"
        }
      ]
    },
    {
      "id": "tests-async-client",
      "category": "testing",
      "title": "Set Tests Client Async from Day 0",
      "tags": [
        "testing",
        "async",
        "httpx",
        "client"
      ],
      "summary": "Writing integration tests with DB will most likely lead to messed up event loop errors. Set the async test client immediately.",
      "content": "Writing integration tests with DB will most likely lead to messed up event loop errors in the future. Set the async test client immediately, e.g. httpx.",
      "code_examples": [
        {
          "description": "Async test client",
          "code": "import pytest\nfrom httpx import AsyncClient, ASGITransport\nfrom src.main import app\n\n@pytest.fixture\nasync def client() -> AsyncGenerator[AsyncClient, None]:\n    async with AsyncClient(\n        transport=ASGITransport(app=app),\n        base_url=\"http://test\"\n    ) as client:\n        yield client\n\n@pytest.mark.asyncio\nasync def test_create_post(client: AsyncClient):\n    resp = await client.post(\"/posts\")\n    assert resp.status_code == 201"
        }
      ]
    },
    {
      "id": "use-ruff",
      "category": "tooling",
      "title": "Use Ruff",
      "tags": [
        "ruff",
        "linter",
        "formatter",
        "black",
        "isort"
      ],
      "summary": "Ruff is blazingly-fast linter that replaces black, autoflake, isort, and supports more than 600 lint rules.",
      "content": "Ruff is a blazingly-fast new linter that replaces black, autoflake, isort, and supports more than 600 lint rules.\n\nIt's a popular good practice to use pre-commit hooks, but just using the script was ok for us.",
      "code_examples": [
        {
          "description": "Ruff script",
          "code": "#!/bin/sh -e\nset -x\n\nruff check --fix src\nruff format src"
        }
      ]
    }
  ]
}